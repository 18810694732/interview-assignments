# 短链的好处
   - ![image.png](https://cdn.nlark.com/yuque/0/2021/png/12909021/1616634713998-6f2ff782-c7ef-41a1-9f13-8da2a62cb97a.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=782&size=236873&status=done&style=none&width=782)
   - 浏览器的地址栏上最终会显示一条如下的长链
   - ![](https://cdn.nlark.com/yuque/0/2021/png/12909021/1616634750076-080668af-cf95-4a7a-8166-485889c3469e.png#align=left&display=inline&height=35&margin=%5Bobject%20Object%5D&originHeight=35&originWidth=809&size=0&status=done&style=none&width=809)
   - 链接变短，在对内容长度有限制的平台发文，可编辑的文字就变多了
   - 二维码的密集问题
# 短链跳转的基本原理

- 浏览器抓包查看network详情
   - 


![](https://cdn.nlark.com/yuque/0/2021/png/12909021/1616634891709-a340a2bb-7489-4f66-ac31-bcd0b4106c1c.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&originHeight=298&originWidth=1080&size=0&status=done&style=none&width=1080)

   - 执行原理图

![](https://cdn.nlark.com/yuque/0/2021/png/12909021/1616634854607-b105c14e-6d75-4e45-8757-06d120f707d7.png#align=left&display=inline&height=559&margin=%5Bobject%20Object%5D&originHeight=559&originWidth=851&size=0&status=done&style=none&width=851)这时候引入了301与302的区别  都是重定向  决定取哪个的问题？301属于永久重定向，302属于临时重定向
# 短链生成的几种方法

- **哈希算法（本项目中的实际落地方案）**
   - 使用 Google 的 MurmurHash 算法，生成32bit(官方是可以生成32/128两种)哈希值
      - 经过百度寻求帮助，MurmurHash生成的哈希值为10进制的，看着还是有点长，所以项目中又做了10进制-->62进制，最终呈现出6位62进制的字符串
      - 上述方案中会出现一个问题，哈希值生成时，会有冲突的风险，(官方反应基本上不太可能冲突，所以项目中没有进行逻辑处理)，**优化方案如下**：在插入时进行查询校验，但在高并发场景下此方案会降低服务性能，因为可能要进行多次磁盘IO；本项目中构建了一个基于本地的布隆过滤器，将短域码与长链的对应关系存于其中，这样就可以减少磁盘IO的次数降低服务压力。
- **自增序列算法**
   - 类 uuid
   - 使用Redis，做一个发号器服务
      - 这种方案需要考虑持久化方案，数据量上去以后，考虑灾备等，成本有点点高
   - Snowflake（老生常谈的雪花id）
      - 分布式环境下需要考虑其唯一性，引入分布式锁
   - Mysql 自增主键
      - 可以做一个发号表，跟Redis的发号器原理类似，此表中每次都会先放一整个号段的id号，当请求进来之后去这个发号表中去找对应的id，需要判断其是否大于结束号，如若则进行重新分配号段进行获取id号；
- **openResty**
   - 它是一个基于Nginx与Lua的高性能Web平台，此项目中未实现，只是做了些了解，发现这个东西能扛得住100w+的并发量，可以用它做一些秒杀场景之类的



